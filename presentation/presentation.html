<!DOCTYPE html>
<html>
<head>
<title> A Taste of Haskell for Scala Programmers</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel='stylesheet' type='text/css' href='style.css' />
</head>
<body>
<textarea id="source">

class: center, middle, transition, intro

#  A Taste of Haskell for Scala Programmers

.leftFloat[Underscore - TODO 2015]
.rightFloat[Daniel Beskin]
---

class: center, middle, transition

.xkcd[![](xkcd.png)]

???
- This talk will be about the language Haskell
- Here's the obligatory XKCD comic
- It's a common misconception that Haskell is this ivory tower language, that has no practical use
- So to sort this point out

---

class: center, middle

.bigCode[`main = putStrLn "Hello World!"`]

???

- This code does exactly what you'd expect
- Which proves once and for all that Haskell really is a practical language

---
layout: true

## What?

---

- Haskell is a standardized, general-purpose purely functional programming language, with non-strict semantics and strong static typing

???
- Although very accurate, it doesn't really convey the spirit of the language
- It makes it more academic rather than a real programming language

---

- ~~Haskell is a standardized, general-purpose purely functional programming language, with non-strict semantics and strong static typing~~

???
- Let's try again

--

- Haskell is a programming language, you can Get Stuff Done&#8482; with it

---
layout: false

## Why?

- Influence on Scala

- The "missing documentation" for Scalaz

- Better suited for pure functional programming

- A reading language


???
- There is quite a bit of influence Haskell on Scala, e.g. the type system or for comprehensions
- Learning Haskell might improve one's understanding of these concepts in Scala
- Many things in Scalaz are ports of similar Haskell code, learning Haskell can help with figuring out Scalaz 
- For example, theres's a Haskell site called Typeclassopedia that can help with the Scalaz typeclass hierarchy
- Since Haskell does not try to blend FP with OO, it's much better suited for pure FP than Scala
- Sometimes it's easier to figure out some FP concept in Haskell and then port it to Scala, rather than trying to learn it directly in Scala
- Because of the above, a lot of FP related advances (research or just blog posts) are being done in Haskell
- Learning to read Haskell can open up a whole world of reading material on these topics

---

## How?

We'll build Twitter-grep, a small server-side application that:

- Accepts GET (@twitter-name, regex)

- Fetches @twitter-name timeline

- Filters timeline with regex expression

- Serves an HTML page with results

???

- This is going to be an example driven tutorial
- We'll try to build a "real world" application, with all sorts of side effects and things
- So no Fibonacci
- The aim is not to be a comprehensive introduction to Haskell, but rather to convey the feeling of programming in Haskell
- Accepts GET requests with a Twitter user name and a regex-like expression
- Fetches the user's Twitter timeline via the Twitter API
- Filters out the tweets that do not match the regex expression
- Produces an HTML page with the resulting tweets

---
layout: false
class: center, middle, transition

Haskell Syntax Primer

.tweet-syntax[![](tweet_syntax.png)]

???

- But first, a quick tour of Haskell syntax
- This by no means a full introduction to Haskell syntax
- It should be enough that you'll be able to follow along with the examples we're going to see further down the road

---
Definitions
```

x = 3


y = 3 + x


name = "Keyser Soze"


{{content}}
```
???
- A Haskell program is made up of definitions
- The simplest kind are just constants
--
addLists ls1 ls2 = ls1 ++ ls2


{{content}}
???
- Next there are functions
- Note that function arguments do not require parentheses
--
addLists [1, 2, 3] [4, 5] -- [1,2,3,4,5]


{{content}}
???
- We apply functions by juxtaposition 
- A double dash is a comment in Haskell
--
map f ls = case ls of
  []  -> []
  h:t -> f h : map f t
 

{{content}}
???
- We can define the familiar `map` function
- Haskell has built-in syntax for lists, and we can do pattern matching on using a `case` expression
--
map' f []    = []
map' f (h:t) = f h : map' f t

???
- Another way of doing pattern matching, is by splitting the function definitions into the relevant cases
- Both ways are equivalent
- Apostrophe is a valid character in a Haskell identifier
- So far, we didn't mention any types anywhere
- This is possible, since unlike Scala, Haskell has *global* type inference
- So it is almost always possible (but not always recommended) to omit type signatures and the compiler just infers it
- If we actually let the compiler infer the types we get the following:
---
Definitions
```
x :: Integer
x = 3

y :: Integer
y = 3 + x

name :: [Char]
name = "Keyser Soze"

addLists :: [a] -> [a] -> [a]
addLists ls1 ls2 = ls1 ++ ls2

longList :: [Integer]
longList = addLists [1, 2, 3] [4, 5] -- [1, 2, 3, 4, 5]

map :: (a -> b) -> [a] -> [b]
map f ls = case ls of
  []  -> []
  h:t -> f h : map f t
 
map' :: (a -> b) -> [a] -> [b] 
map' f []    = []
map' f (h:t) = f h : map' f t
```

???
- From which we can learn a number of things
- Type signatures use a double colon and are written separately
- The default Haskell strings are just lists of characters, and can be treated as such (`String` is just a synonym for `[Char]`)
- Lower case letters in a type signature act as type parameters
- From the signature of both `addLists` and `map` we see that the functions in Haskell are curried by default
- This actually works very nicely with function application syntax
- Let's see an example
---
Currying
```
mapPlusTwo :: [Integer] -> [Integer]
mapPlusTwo = map (\x -> x + 2)

{{content}}
```
???
- Here we apply `map` to its first argument
- The slash syntax stands for an anonymous function
- As we can see, this produces a new function, where we already used `map`'s first argument
- There a nicer way to write the same thing
--

mapPlusTwo' = map (+ 2)

{{content}}
???
- The parenthesis partially applies the `+` operator
- And we can apply `mapPlusTwo` to a list and get the expected result
- Let's move on to some more syntax
- We've seen a number of operators thus far, Haskell actually lets us define operators on our own
--

mapPlusTwo [1, 2, 3] -- [3, 4, 5]

---
Custom operators
```
($) :: (a -> b) -> a -> b 
f $ x = f x
  
{{content}}
```
???
- We can define custom operator in Haskell, just like any function
- This is the function application operator, it's defined in Haskell Prelude (which is like Scala's Predef) and imported by default
- It might seem useless, but because of its defined with low precedence, and this allows us to save some parenthesis
- Suppose we want to write:
--
map (+ 2) (filter (3 <) [1, 2, 3, 4, 5])

{{content}}
???
- Here we are first filtering a list and then mapping it
- With the application operator we can write:
--
map (+ 2) $ filter (3 <) [1, 2, 3, 4, 5] -- [6, 7]
    
???
- This concludes the basic syntax
- Let's move on to type definitions
- There are a number of ways to define types in Haskell
- But first let's start with a Scala example

---
Algebraic data types
```scala
type User = String

sealed trait TwitterAPI

case class Timeline(user: User, count: Int) extends TwitterAPI
case class StatusUpdate(user: User, status: String) extends TwitterAPI
case class Search(query: String) extends TwitterAPI
```
???
- This should be fairly familiar code
- We have a type synonym and an algebraic data type
- In this case this is a simplistic representation of the Twitter API
- We have three cases, each corresponds to an action in the API
- Each action takes some arguments
- Now for the (sort of) equivalent Haskell code

---
Algebraic data types
```
type User = String

data TwitterAPI = Timeline User Integer 
                | StatusUpdate User String 
                | Search String 
                deriving (Eq, Show)
      
      
{{content}}
```

???
- There's a lot less noise here
- The `deriving` bit is optional, but is provides the Haskell equivalent of `toString` and `equals`
- This is done via typeclasses, which we'll discuss soon
- Each case defines a constructor function, taking arguments of the specified types
- They can be used as follows
- We also get pattern matching for free (just like with case classes)
--
tl :: TwitterAPI
tl = Timeline "foo" 15

update :: TwitterAPI
update = StatusUpdate "foo" "like, whatever"

search :: TwitterAPI
search = Search "I dunno"

???
- Note that, unlike Scala, there is no subtyping here, so all values have the same type, `TwitterAPI`
- Let's move on to typeclasses
- But first, a reminder of typeclasses in Scala
- We can encode typeclasses in Scala in the following way
- Suppose we want a `Functor` typeclass
---
Typeclasses
```scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}

implicit val optionFunctor = new Functor[Option] {
  def map[A, B](opt: Option[A])(f: A => B) = opt map f
}

{{content}}
```

???
- First we define a trait with the `Functor` methods
- In this case, mapping inside some container-like type
- Next we create an instance of the typeclass for the `Option` type constructor
- And now we can write a method that is generic in the `Functor` instance
--

def addWorld[F[_]](fs: F[String])(implicit f: Functor[F]): F[String] = 
  f.map(fs)(_ + " World!")

addWorld(Option("Hello")) // Some(Hello World!)

???
- Typeclasses were actually invented for Haskell, and so it has special syntax for it
- For example, the `Functor` typeclass is the defined as follows
---
Typeclasses
```
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  
{{content}}
```

???
- This can be read as: the typeclass `Functor` accepts a type constructor `f` and has one method, `fmap`
- `fmap` take a function from `a` to `b`, then an instance of `f` of `a`, and produces an `f` of `b`
- Note that Haskell is inferring that `f` is a type constructor and not a simple type, it can be seen from the usage of `f` in `fmap`
- The name of `fmap` is not `map` for historical reasons
- This typeclass is part of the standard library
- We can now make an instance of `Functor` for `Maybe` the Haskell equivalent of `Option`
--

data Maybe a = Just a | Nothing deriving (Eq, Show)


instance Functor Maybe where
  fmap f (Just x) = Just $ f x
  fmap _ Nothing = Nothing
  
{{content}}
???
- First the definition of `Maybe`, which is the same as the algebraic data types we've seen before, except that it has a type parameter
- We just go by cases of `Maybe`, and apply `f` when it's possible
- As in the Scala case, we can write a function that is generic in the typeclass instance
--

addWorld :: Functor f => f String -> f String 
addWorld fs = fmap (++ " World!") fs

addWorld $ Just "Hello" -- Just "Hello World!"

???
- The part before the thick arrow is the typeclass constraint
- Which can be read as: given that there is an instance of `Functor` for `f`, do the following
- When we specify the typeclass constraint it automatically brings the relevant methods into scope
- So we have access to `fmap`, which is chosen by the compiler to be the right one 
- Similar to how Scala's implicits work
- Let's do a slightly more complicated example
- The `Applicative` typeclass, it's not that common in Scala, probably because the syntax does not work that well with it
- But it is the typeclasses behind Scalaz's `Validation`
- It is roughly defined like this:
---
More typeclasses
```
class Functor f => Applicative f where
    pure :: a -> f a

    (<*>) :: f (a -> b) -> f a -> f b
    
{{content}}
```

???
- It actually has more methods, but they have default implementations
- We see that `Applicative` has a typeclass constraint of its own, `Functor`
- Which means that every `Applicative` is also a `Functor`, that is, `Applicative` generalizes `Functor`
- If we think of `f` as some sort of a container with an effect, than `pure` takes a plain value a puts in the container
- The `<*>` is called "sequential application" the signature tells us what it does
- If we have a function inside the "container", we can use sequential application to apply the function to another value inside another container
- Let's implement this class for `Maybe`
--

instance Applicative Maybe where
  pure x = Just x
  
  Just f <*> Just x = Just $ f x
  _      <*> _      = Nothing
  
???
- This is the obvious implementation, in the sense that there are some rules that `Applicative` should obey, and this is the only reasonable way to obey them
- `pure` just wraps a value in a `Just`
- The application operator is non-trivial only when both sides are `Just`s, then we apply the function
- In all other cases we just return `Nothing`
- Let's see what can we do with it
---
Using `Applicative`
```
Search :: String -> TwitterAPI

pure Search :: Maybe (String -> TwitterAPI)

pure Search <*> Just "I dunno" -- Just (Search "I dunno")

{{content}}
```
???
- `Search` is function that takes a string, we lift it into our `Applicative`
- Then we apply it a `Just` value
- But the whole `pure ... <*>`, is just a map
- We can define an operator that does this and this becomes
--
Search <$> Just "I dunno"
???
- The `<$>` stands for `fmap`
- Let's try a more complicated example
---
Using `Applicative`

```
Timeline :: User -> Integer -> TwitterAPI

pure Timeline :: Maybe (User -> Integer -> TwitterAPI)

pure Timeline <*> Just "Keyser" <*> Just 5 -- Just (Timeline "Keyser" 5)

pure Timeline <*> Nothing <*> Just 5 -- Nothing

{{content}}
```
???
- In this case lift the `Timeline` function, which takes two arguments
- So we use the sequential application operator to two values
- But if any of the values is missing, the whole thing fails
- We can again use the `<$>` dollar operator to make this look nicer
--

Timeline <$> Just "Keyser" <*> Just 5

???
- Which is a very neat way to apply function inside of containers or contexts
- Because of currying this pattern works for any number of arguments and for any `Applicative`
--
```
f <$> x1 <*> x2 <*> ... <*> xn
```
???
- If you're familiar with Scalaz's `Validation`, this should look familiar
- With all this in hand we are ready to start implementing our application
- Any questions so far?

---
layout: false
class: center, middle, transition

The Parser

.tweet-regex[![](tweet_regex.png)]

???

- As we described before, the program is going to accept regex-like string
- We could some library to do the matching with the regex
- But we won't be doing this, instead, it'll be more instructive to implement our own (simplified) regex engine
- To do this, we'll use parser combinators, which you may be familiar with from Scala
- Again, Haskell has some very good parser combinators libraries
- But instead of using them, we'll quickly implement one on our own
- For what we need, it's actually not that much of an effort

---
The parsing function
```
newtype Parser a = Parser { parse :: String -> [(a, String)] }
```
???
- A parser is a function that takes a string (or rather, a stream of characters), which is the current state of parsing, and produces a list of pairs
- Each pair designates a possible parsing of the string
- The first item in the pair, of type `a`, is the result of parsing
- The second item is the remaining characters, that is, the new state of the parser
- To actually run the parser, we apply the function to a string and see the results
- If the list of results is empty, then there is no way to parse the string

--
Advancing the stream
```
satisfy :: (Char -> Bool) -> Parser String
satisfy predicate = Parser $ \s ->
  case s of
    []   -> []
    c:cs -> 
      if predicate c
      then [([c], cs)]
      else []
```

???
- This is the main function we'll use to parse something
- It takes a predicate and creates a new parsing function
- The parser takes one character from the input
- If the character matches the predicate, the result is a string with this character
- The new state is the input minus the first character
- If the predicate fails, the whole parse fails, so the result is the empty list
- With this function in hand, we can implement a number of simple parsers
---
Some simple parsers
```
char :: Char -> Parser String
char c = satisfy (c ==)


{{content}}
```
???
- This function takes a single character and checks whether the next character in the string matches it
- In the same vain, we can write more parsers
--
dot = satisfy $ const True


alphaNum = satisfy isAlphaNum


oneOf, noneOf :: [Char] -> Parser String
oneOf cs = satisfy $ \c -> elem c cs
noneOf cs = satisfy $ \c -> notElem c cs

???
- `dot` matches any character
- The expression `const True` return a function that return `True` on any input
- `alphaNum` matches any alphanumeric character
- In `oneOf` and `noneOf` we are taking a list of characters and creating a predicate that checks the presence (or abscence) of any of the characters in the stream
---
Using the parsers

```
p1 = char 'a'

p2 = oneOf "abc"


parse p1 "abc" -- [("a","bc")]
parse p2 "cde" -- [("c","de")]
parse p2 "def" -- []
```
???
- We can create simple parsers with what we have
- The `parse` function unwraps our parsing function, and we can apply it to the input
- In the first two cases there is only possible parsing, and we consume one character leaving the rest of the string
- In the last case there are no parsings, so the result is empty
- So far we have a bunch of simple parsers, but we don't have any way to combine them into more complicated parsers
- Since we want parser combinators we'll need to write some combinators to go along with the parsers
- To do this, we'll need some infrastructure, and for this we are going to implement a number of typeclasses
- We start with `Functor`

---
The infrastructure
```
instance Functor Parser where
  fmap f (Parser p) = Parser $ \s -> 
    [(f a, s') | (a, s') <- p s]
    
    
{{content}}
```
???
- There's a bit of new syntax here, it's called "list comprehensions". It's like Scala's for comprehensions but specialized to lists
- What's to the left of the vertical bar is the result of the whole thing, to the right we deconstruct the list
- So, given a mapping function (`f`) and a parsing function (`p`), we create a new parser function. 
- In this function, we run the original function on the incoming string
- Then we run over the results and apply `f` in the appropriate place
- Next we have the `Applicative` instance
--
instance Applicative Parser where
  pure a = Parser $ \s -> [(a, s)]

  Parser pf <*> Parser pa = Parser $ \s ->
    [(f a, s'') | (f, s') <- pf s, (a, s'') <- pa s']
    
???
- First there's `pure`, which just takes a value and creates a new parsing function around it
- Sequential application is quite similar to `fmap` from before, except that we now have two parser functions to deal with
- In the first step we unwrap the function hidden in the first parser, in the second we unwrap the value hidden in the second
- Then we apply the function to the value
- Notice that we are careful to propagate the state of the parser between the first parser and the second to the final result
- When we use sequential application, we run both parsers one after the other
- This gives us a way to combine two parser into a new one, let's see an example
---
Combining parsers
```
(&) :: Parser String -> Parser String -> Parser String
(&) pa pb = (++) <$> pa <*> pb

(++) :: [a] -> [a] -> [a]


{{content}}
```

???
- Here we are defining an operator that takes two parser and runs them one after the other and concatenates the results
- Notice the applicative syntax
- In here the `++` operator is used as a two arguments function, we `fmap` and sequential application to apply this operator inside the parsers
- Using `&` we can define the `string` function that matches a whole string
--
string :: String -> Parser String
string ""     = pure ""
string (c:cs) = char c & string cs

{{content}}
???
- The `string` parser takes a string and creates a parser that mathces it in the input
- The empty string creates a trivial parser that matches anything
- In case the string is not empty, we are deconstructing it into the first character and the rest
- We create a parser with the first character and combine it using `&` with a parser created with the rest of the characters
- We'll need another typeclass to continue, the `Alternative` class
---
More infrastructure
```
class Applicative f => Alternative f where
    empty :: f a
    
    (<|>) :: f a -> f a -> f a
    
    many :: f a -> f [a]
    some :: f a -> f [a]
    
    
{{content}}
```

???
- The definition of the class is approximately this
- Given that `f` has an instance of `Applicative`, we define the `Alternative` instance
- In the context of parsing, `empty` is a failed parse, i.e. the empty list
- The `<|>` operator, is the alternation operator, it takes two parser and runs them in parallel
- `many` and `some` run a single parser as many times as possible and aggregate the results into a list
- `many` runs the parser zero or more times, while `some` runs it at least once
- Let's see the implementation
--
instance Alternative Parser where
  empty = Parser $ \s -> []

  Parser pa <|> Parser pb = Parser $ \s -> pa s ++ pb s

???
- So `empty` is like we said
- And the alternative creates a new function that runs the parsers on the same input, and concatenates the results
- This provides backtracking in case we have many possible parsings
- We don't need to implement `some` and `many` since they have default implementation in terms of the alternation operator
- With this in hand we can combine parsers in a new way, for example
---
Using the new combinators
```
string "Keyser" <|> string "Soze"


{{content}}
```
???
- This matches either the string "Keyser" or "Soze"
--
star, plus :: Parser String -> Parser String
star p = concat <$> many p
plus p = concat <$> some p


{{content}}
???
- `star` takes a parser and applies it zero or more times using `many`
- The result is a list of strings, we than map the the concatenation function into the parser, which gives a single long string
- `plus` is the same thing, but applies the operator one or more times
- The parser the we implemented so far let us define another useful combinator
--
has :: Parser String -> Parser String
has p = star dot *> p <* star dot

???
- `has` takes a parser and tries to match it anywhere inside of the input string
- It does that using two new operators, `*>` and `<*`, these are provided by the `Applicative` library
- They are similar to `<*>`, the sequence two parsers together, but they discard the result on either the left or right
- In our case, we first use `star dot` to match any number of characters
- Then we discard the result, and continue matching `p`
- After that we again match any number of characters and discard them
- As a result, if `p` matches anywhere inside the input, `has p` matches this string
- The last thing we need for our parser combinator library is a way to actually run parsers on strings
- We do this with the match function
---
Running a parser
```
match :: Parser a -> String -> [a]
match p str = map fst $ parse (p <* eof) str
        
        
{{content}}
```
???
- Match takes any parser and a string and produces a list of results
- In the second part we create a new parser which is a combination of `p` and the `eof` parser
- The `eof` matches the end of the string, we'll see its definition in a moment
- So `p <* eof` matches `p` only if it reaches the end of the input, and discards the result of `eof`
- The `parse` unwraps our parsing function, which we then run against the input string
- The result is a list of pairs, where the first is a possible result, and the second is the remaining input
- We now map the `fst` function over this list, and discard the remaining inputs part
- And here's the `eof` parser
--
eof :: Parser ()
eof = Parser $ \s ->
  case s of
    "" -> [((), "")]
    _  -> []
    
???
- It inspects the input, if its empty we succeed and leave the unit value
- Otherwise we fail
- These are all the combinators we'll need
- To see that it actually works, we can run a simple example
---
A bigger example

```
p = oneOf "Kk" & string "eyser" & plus dot & oneOf "Ss" & string "oze"
-- As regex: [Kk]aiser.+[Ss]oze

match p "Keyser Soze" -- ["Keyser Soze"]
match p "No Keyser" -- []
match p "Keyser soze" -- ["Keyser soze"]
match p "KeyserSoze" -- []
```

???
- A larger example, we combine a number of parsers together
- They are equivalent to this regular expression
- As you can see, we wrote a small domain specific language for parsers
- And they work as expected
- With this, we have the foundation to implement our little regular expressions engines
---












  </textarea>
	<script
		src="remark-0.10.2.min.js"
		type="text/javascript">
	</script>
	<script type="text/javascript">
    var slideshow = remark.create({ 
		highlightLanguage: 'haskell', 
		highlightStyle: 'magula' // default, googlecode, magula, vs
	});
    //document.addEventListener('click', function (e) { slideshow.gotoNextSlide() }, false);
	</script>
</body>
</html>